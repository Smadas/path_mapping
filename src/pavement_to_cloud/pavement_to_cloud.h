#ifndef PROJECT_PAVEMENTTOCLOUD_H
#define PROJECT_PAVEMENTTOCLOUD_H

#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <sensor_msgs/Image.h>

#include <sensor_msgs/PointCloud.h>

//Cm - centimeters

#define DEFAULT_PAV_Z 0.01 //10cm
#define PAV_LINE_RESOLUTION 1 //5cm
#define MAX_DISTANCE_CM 500000 //500m
#define MAX_NUM_POINTS_POINTCLOUD 10000

#define WIDTH_K -0.1//0.3051948052
#define WIDTH_Q 10//240.7532467532
#define DIST_K 1.7321
#define DIST_Q -127.3839
#define PIC_WIDTH_PIX 1280
#define PIC_HEIGHT_PIX 700
#define PIC_CALIB_WIDTH_PIX 2592
#define PIC_CALIB_HEIGHT_PIX 1944
#define CALIB_OBJ_WIDTH_MM 300//mm
#define CAMERA_POSE_X 0
#define CAMERA_POSE_Y 800 //mm
#define CAMERA_ANGLE 30 //old value 60//degrees
#define IMG_OFFSET 1000 //550 //mm

#define A_KVADR (lineEquationC.slope*lineEquationC.slope + 1)
#define B_KVADR (-(2.0*pointCm1.x + 2.0*lineEquationC.slope*(pointCm1.y - lineEquationC.yIntercept)))
#define C_KVADR (pointCm1.x*pointCm1.x - m2cm(PAV_LINE_RESOLUTION)*m2cm(PAV_LINE_RESOLUTION) + (pointCm1.y - lineEquationC.yIntercept)*(pointCm1.y - lineEquationC.yIntercept))

struct pointCm
{
    double x = 0;
    double y = 0;
    double z = DEFAULT_PAV_Z;
};
struct lineEquation
{
    double slope = 0;
    double yIntercept = 0;
};
struct linePointsPix
{
    cv::Point start;
    cv::Point end;
};
struct linePointsCm
{
    pointCm start;
    pointCm end;
};
struct pavFragmentPix
{
    linePointsPix left;
    linePointsPix right;
};
struct pavFragmentCm
{
    linePointsCm left;
    linePointsCm right;
};
struct pavFragment
{
    pavFragmentPix pix;
    pavFragmentCm cm;
};

void putPavementFragmentIntoCloud(sensor_msgs::PointCloud *pointCloud_msg, pavFragment *pavFragmentC);
void changePavPointsToCm(pavFragment *pavFragmentC);
int getWidthPix(cv::Point pointLeft, cv::Point pointRight);
int getWidthCm(int widthPix, int heightPix);
cv::Point getCenterOfPavement(cv::Point pointLeft, cv::Point pointRight);
pointCm getCenterOfPavementCm(int pavCenterFromImgCenterCm, cv::Point pavementCenterPix);
int computeCmX(pointCm pavCenterCm, int pavementWidthCm, bool isLeft);
void changeToCmX(pavFragment *pavFragmentC);
int getFragmentLengthPixY(linePointsCm linePointsCmC);
int getFragmentLengthCmY(int startLineY, int endLineY, pointCm *startLine, pointCm *endLine);
void changeToCmY(pavFragment *pavFragmentC);
void putPavementLineIntoCloud(sensor_msgs::PointCloud *pointCloud_msg, pointCm lineCmStart, pointCm lineCmEnd);
lineEquation computeLineSlope(pointCm lineCmStart, pointCm lineCmEnd);
void putPointsOfLineToCloud(sensor_msgs::PointCloud *pointCloud_msg, lineEquation lineEquationC, pointCm lineCmStart, pointCm lineCmEnd);

double cm2m(double cm);
double m2cm(double m);

lineEquation calibrationWidth();
void calibrationDistance();

#endif //PROJECT_PAVEMENTTOCLOUD_H